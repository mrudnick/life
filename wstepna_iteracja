-module(lifegame).
-export([create_table/1, test_avg/4, create_neighbours/1, iterate/3, write_file/2]).
-record(field,{y= 0,x= 0,value= 0}).

% funkcje do peracji na sasiadach:
neighbours_array() -> [{-1,0},{-1,-1},{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1}].
create_neighbours({Y,X}) -> [ {C+Y,D+X} || {C,D} <- [{-1,0},{-1,-1},{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1}]].

% funkcje tworzące tablicę:

create_rows(1,0,Rozmiar,[H|T]) -> [H|T];
create_rows(Wiersz,0,Rozmiar, [H|T]) -> create_rows(Wiersz-1,Rozmiar-1,Rozmiar, [ [#field{y=Wiersz - 1, x= Rozmiar , value= random:uniform(2) -1} ] | [H|T]]);
create_rows(Wiersz,Kolumna,Rozmiar, [H|T]) -> create_rows(Wiersz,Kolumna-1,Rozmiar, [[#field{y= Wiersz, x= Kolumna , value= random:uniform(2) -1}|H]|T]).

create_table(0) -> [];
create_table(N) -> create_rows(N,N-1,N,[[#field{x= N, y= N, value=random:uniform(2) -1}]]).


%przyjmuje jeden wiersz z tablicy- zwraca wiersz do nowej tablicy.
%iterate_row([H|T]) -> lists:map(check_next,[H|T]). %[ check_next(A) || A <- [H|T]].

% pobieranie elementow i wartosci z tablicy
get_element(Y,X, Tab) -> lists:nth(X,lists:nth(Y, Tab)).
get_value(A = #field{})-> A#field.value.


% sprawdzenie zasady gry w życie:
rule(1, N) when (N == 2) or (N == 3) -> 1;
rule(1, _) -> 0;
rule(0, 3) -> 1;	
rule(0,_) -> 0.


check_next(El= #field{}, Tab) -> rule(get_value(get_element(El#field.y, El#field.x, Tab)) ,lists:sum([get_value(get_element(A, B, Tab)) || {A,B} <- create_neighbours({El#field.y,El#field.x}), A>=1, A=<length(Tab), B>=1, B=<length(Tab)])).

%przyjmuje jeden wiersz z tablicy oraz cala tablice zeby szukac sasiadow- zwraca wiersz do nowej tablicy.
%%
%%
iterate_row([H|T], Tab) -> [ #field{y= A#field.y, x= A#field.x, value= check_next(A, Tab)} || A <- [H|T]].

% przyjmuje aktualną tablice i pustą - nowa tablica która będzie tworzona na podstawie poprzedniej... zwraca nową tablicę.
%%
%%
iterate(Tab,0, [H2|T2]) -> [H2|T2];
iterate(Tab,N,[H2|T2]) -> iterate(Tab,N-1,[iterate_row(lists:nth(N,Tab), Tab)|[H2|T2]]);
iterate(Tab,N,[]) -> iterate(Tab, N-1, [iterate_row(lists:nth(N,Tab), Tab)]).



% funkcja testująca:

test_avg(M, F, A, N) when N > 0 ->
    L = test_loop(M, F, A, N, []),
    Length = length(L),
    Min = lists:min(L),
    Max = lists:max(L),
    Med = lists:nth(round((Length / 2)), lists:sort(L)),
    Avg = round(lists:foldl(fun(X, Sum) -> X + Sum end, 0, L) / Length),
    io:format("Range: ~b - ~b mics~n"
          "Median: ~b mics~n"
          "Average: ~b mics~n",
          [Min, Max, Med, Avg]),
    Med.
 
test_loop(_M, _F, _A, 0, List) ->
    List;
test_loop(M, F, A, N, List) ->
    {T, _Result} = timer:tc(M, F, A),
    test_loop(M, F, A, N - 1, [T|List]).

